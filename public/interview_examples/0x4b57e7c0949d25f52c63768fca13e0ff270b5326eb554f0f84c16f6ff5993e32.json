{
    "revela": "module 0x8ec24188ca1d4fb80dc8254a6a142256c8a76ec1cd0251c5a128979919d75509::main {\n    struct Leaderboard<phantom T0> has store, key {\n        id: 0x2::object::UID,\n        creator: address,\n        reward: 0x2::balance::Balance<T0>,\n        claimed_reward_amount: u64,\n        max_leaderboard_size: u64,\n        top_projects: vector<0x2::object::ID>,\n        top_balances: vector<u64>,\n        end_timestamp_ms: u64,\n    }\n    \n    struct ProjectManager has store, key {\n        id: 0x2::object::UID,\n        projects: 0x2::bag::Bag,\n    }\n    \n    struct Project<phantom T0> has store, key {\n        id: 0x2::object::UID,\n        leaderboard_id: 0x2::object::ID,\n        balance: 0x2::balance::Balance<T0>,\n    }\n    \n    struct ProjectOwnerCap<phantom T0> has store, key {\n        id: 0x2::object::UID,\n        project_id: 0x2::object::ID,\n    }\n \n    fun init(arg0: &mut 0x2::tx_context::TxContext) {\n        let v0 = ProjectManager{\n            id       : 0x2::object::new(arg0), \n            projects : 0x2::bag::new(arg0),\n        };\n        0x2::transfer::share_object<ProjectManager>(v0);\n    }\n   \n    public fun check_out_project<T0>(arg0: &mut ProjectManager, arg1: &Leaderboard<T0>, arg2: 0x2::object::ID, arg3: &mut 0x2::tx_context::TxContext) {\n        let v0 = 0x2::bag::borrow_mut<0x2::object::ID, Project<T0>>(&mut arg0.projects, arg2);\n        0x2::transfer::public_transfer<0x2::coin::Coin<T0>>(0x2::coin::from_balance<T0>(0x2::balance::split<T0>(&mut v0.balance, 0x2::balance::value<T0>(&v0.balance)), arg3), arg1.creator);\n    }\n    \n    public fun create_leaderboard<T0>(arg0: u64, arg1: 0x2::coin::Coin<T0>, arg2: &mut 0x2::tx_context::TxContext) {\n        let v0 = Leaderboard<T0>{\n            id                    : 0x2::object::new(arg2), \n            creator               : 0x2::tx_context::sender(arg2), \n            reward                : 0x2::coin::into_balance<T0>(arg1), \n            claimed_reward_amount : 0, \n            max_leaderboard_size  : 30, \n            top_projects          : 0x1::vector::empty<0x2::object::ID>(), \n            top_balances          : 0x1::vector::empty<u64>(), \n            end_timestamp_ms      : arg0,\n        };\n        0x2::transfer::share_object<Leaderboard<T0>>(v0);\n    }\n    \n    public fun deposit_reward<T0>(arg0: &mut Leaderboard<T0>, arg1: 0x2::coin::Coin<T0>, arg2: &0x2::clock::Clock, arg3: &mut 0x2::tx_context::TxContext) {\n        assert!(0x2::tx_context::sender(arg3) == arg0.creator, 1);\n        0x2::balance::join<T0>(&mut arg0.reward, 0x2::coin::into_balance<T0>(arg1));\n        update_end_timestamp<T0>(arg0, 0x2::clock::timestamp_ms(arg2) + 259200000);\n    }\n    \n    public fun withdraw_reward<T0>(arg0: &mut Leaderboard<T0>, arg1: u64, arg2: &mut 0x2::tx_context::TxContext) : 0x2::coin::Coin<T0> {\n        assert!(0x2::tx_context::sender(arg2) == arg0.creator, 1);\n        0x2::coin::from_balance<T0>(0x2::balance::split<T0>(&mut arg0.reward, arg1), arg2)\n    }\n\n    public fun update_end_timestamp<T0>(arg0: &mut Leaderboard<T0>, arg1: u64) {\n        assert!(arg1 > arg0.end_timestamp_ms, 1);\n        arg0.end_timestamp_ms = arg1;\n    }\n\n    public fun create_project<T0>(arg0: &mut ProjectManager, arg1: &mut Leaderboard<T0>, arg2: 0x2::coin::Coin<T0>, arg3: &mut 0x2::tx_context::TxContext) : ProjectOwnerCap<T0> {\n        let v0 = Project<T0>{\n            id             : 0x2::object::new(arg3), \n            leaderboard_id : 0x2::object::id<Leaderboard<T0>>(arg1), \n            balance        : 0x2::coin::into_balance<T0>(arg2),\n        };\n        let v1 = 0x2::object::id<Project<T0>>(&v0);\n        update_leaderboard<T0>(arg1, v1, 0x2::balance::value<T0>(&v0.balance));\n        0x2::bag::add<0x2::object::ID, Project<T0>>(&mut arg0.projects, v1, v0);\n        ProjectOwnerCap<T0>{\n            id         : 0x2::object::new(arg3), \n            project_id : v1,\n        }\n    }\n\n    public fun withdraw<T0>(arg0: &mut ProjectManager, arg1: ProjectOwnerCap<T0>, arg2: &mut Leaderboard<T0>, arg3: 0x2::object::ID, arg4: &0x2::clock::Clock, arg5: &mut 0x2::tx_context::TxContext) : 0x2::coin::Coin<T0> {\n        let v0 = 0x2::bag::remove<0x2::object::ID, Project<T0>>(&mut arg0.projects, arg3);\n        assert!(0x2::clock::timestamp_ms(arg4) > arg2.end_timestamp_ms && 0x2::object::id<Leaderboard<T0>>(arg2) == v0.leaderboard_id, 1);\n        let Project {\n            id             : v1,\n            leaderboard_id : _,\n            balance        : v3,\n        } = v0;\n        let v4 = v3;\n        0x2::object::delete(v1);\n        let ProjectOwnerCap {\n            id         : v5,\n            project_id : v6,\n        } = arg1;\n        let v7 = v6;\n        0x2::object::delete(v5);\n        let (v8, v9) = 0x1::vector::index_of<0x2::object::ID>(&arg2.top_projects, &v7);\n        if (v8) {\n            0x1::vector::remove<0x2::object::ID>(&mut arg2.top_projects, v9);\n            0x1::vector::remove<u64>(&mut arg2.top_balances, v9);\n            arg2.claimed_reward_amount = arg2.claimed_reward_amount + 1;\n            0x2::balance::join<T0>(&mut v4, 0x2::balance::split<T0>(&mut arg2.reward, 0x2::balance::value<T0>(&arg2.reward) / (30 - arg2.claimed_reward_amount)));\n        };\n        0x2::coin::from_balance<T0>(v4, arg5)\n    }\n\n    public fun vote<T0>(arg0: &mut ProjectManager, arg1: &mut Leaderboard<T0>, arg2: 0x2::object::ID, arg3: 0x2::coin::Coin<T0>, arg4: &0x2::clock::Clock) {\n        let v0 = 0x2::bag::borrow_mut<0x2::object::ID, Project<T0>>(&mut arg0.projects, arg2);\n        assert!(0x2::clock::timestamp_ms(arg4) < arg1.end_timestamp_ms, 1);\n        0x2::balance::join<T0>(&mut v0.balance, 0x2::coin::into_balance<T0>(arg3));\n        update_leaderboard<T0>(arg1, 0x2::object::id<Project<T0>>(v0), 0x2::balance::value<T0>(&v0.balance));\n    }\n\n    fun update_leaderboard<T0>(arg0: &mut Leaderboard<T0>, arg1: 0x2::object::ID, arg2: u64) {\n        let (v0, v1) = 0x1::vector::index_of<0x2::object::ID>(&arg0.top_projects, &arg1);\n        if (v0) {\n            0x1::vector::remove<0x2::object::ID>(&mut arg0.top_projects, v1);\n            0x1::vector::remove<u64>(&mut arg0.top_balances, v1);\n        };\n        let v2 = 0x1::vector::length<u64>(&arg0.top_balances) - 1;\n        let v3 = v2;\n        if (arg2 < *0x1::vector::borrow<u64>(&arg0.top_balances, v2) && 0x1::vector::length<u64>(&arg0.top_balances) < arg0.max_leaderboard_size) {\n            0x1::vector::push_back<0x2::object::ID>(&mut arg0.top_projects, arg1);\n            0x1::vector::push_back<u64>(&mut arg0.top_balances, arg2);\n        } else {\n            if (arg2 > *0x1::vector::borrow<u64>(&arg0.top_balances, v2)) {\n                loop {\n                    if (arg2 > *0x1::vector::borrow<u64>(&arg0.top_balances, v3)) {\n                        break\n                    };\n                    let v4 = v3 - 1;\n                    v3 = v4;\n                    if (v4 == 0) {\n                        break\n                    };\n                };\n                0x1::vector::insert<0x2::object::ID>(&mut arg0.top_projects, arg1, v3);\n                0x1::vector::insert<u64>(&mut arg0.top_balances, arg2, v3);\n                if (0x1::vector::length<u64>(&arg0.top_balances) >= arg0.max_leaderboard_size) {\n                    0x1::vector::pop_back<0x2::object::ID>(&mut arg0.top_projects);\n                    0x1::vector::pop_back<u64>(&mut arg0.top_balances);\n                };\n            };\n        };\n    }\n    \n    // decompiled from Move bytecode v6\n}",
    "source_code": "module interview_example::main {\n    use sui::object::{Self, UID, ID};\n    use sui::balance::{Self, Balance};\n    use sui::coin::{Self, Coin};\n    use std::vector;\n    use sui::tx_context::{Self, TxContext};\n    use sui::transfer;\n    use sui::bag::{Self, Bag};\n    use sui::clock::{Self, Clock};\n\n    const EAuthencationError: u64 = 1;\n\n    struct Leaderboard<phantom T> has key, store {\n        id: UID,\n        creator: address,\n        reward: Balance<T>,\n        claimed_reward_amount: u64,\n        max_leaderboard_size: u64,\n        top_projects: vector<ID>,\n        top_balances: vector<u64>,\n        end_timestamp_ms: u64,\n    }\n\n    struct ProjectManager has key, store {\n        id: UID,\n        projects: Bag,\n    }\n\n    struct Project<phantom T> has key, store {\n        id: UID,\n        leaderboard_id: ID,\n        balance: Balance<T>\n    }\n\n    struct ProjectOwnerCap<phantom T> has key, store {\n        id: UID,\n        project_id: ID,\n    }\n\n    fun init(ctx: &mut TxContext) {\n        let project_manager = ProjectManager {\n            id: object::new(ctx),\n            projects: bag::new(ctx),\n        };\n        transfer::share_object(project_manager);\n    }\n\n    public fun check_out_project<T>(\n        project_manager: &mut ProjectManager,\n        leaderboard: &Leaderboard<T>,\n        project_id: ID,\n        ctx: &mut TxContext\n    ) {\n        let project = bag::borrow_mut<ID, Project<T>>(&mut project_manager.projects, project_id);\n        let project_balance_value = balance::value(&project.balance);\n        let withdrawed_balance = balance::split(&mut project.balance, project_balance_value);\n        let withdrawed_coin = coin::from_balance(withdrawed_balance, ctx);\n        transfer::public_transfer(withdrawed_coin, leaderboard.creator);\n    }\n\n    public fun create_leaderboard<T>(\n        end_timestamp_ms: u64,\n        reward: Coin<T>,\n        ctx: &mut TxContext\n    ){\n        let leaderboard = Leaderboard<T> {\n            id: object::new(ctx),\n            creator: tx_context::sender(ctx),\n            reward: coin::into_balance(reward),\n            claimed_reward_amount: 0,\n            max_leaderboard_size: 30,\n            top_projects: vector::empty(),\n            top_balances: vector::empty(),\n            end_timestamp_ms: end_timestamp_ms,\n        };\n        transfer::share_object(leaderboard);\n    }\n\n    public fun deposit_reward<T>(\n        leaderboard: &mut Leaderboard<T>,\n        reward: Coin<T>,\n        clock: &Clock,\n        ctx: &mut TxContext\n    ){\n        assert!(\n            tx_context::sender(ctx) == leaderboard.creator,\n            EAuthencationError\n        );\n        balance::join(&mut leaderboard.reward, coin::into_balance(reward));\n        let new_timestamp = clock::timestamp_ms(clock) + 3 * 24 * 60 * 60 * 1000;\n        update_end_timestamp(\n            leaderboard,\n            new_timestamp,\n        );\n    }\n\n    public fun withdraw_reward<T>(\n        leaderboard: &mut Leaderboard<T>,\n        amount: u64,\n        ctx: &mut TxContext\n    ) : Coin<T> {\n        assert!(\n            tx_context::sender(ctx) == leaderboard.creator,\n            EAuthencationError\n        );\n        let reward = balance::split(&mut leaderboard.reward, amount);\n        coin::from_balance(reward, ctx)\n    }\n\n    public fun update_end_timestamp<T>(\n        leaderboard: &mut Leaderboard<T>,\n        end_timestamp_ms: u64\n    ){\n        assert!(\n            end_timestamp_ms > leaderboard.end_timestamp_ms,\n            EAuthencationError\n        );\n        leaderboard.end_timestamp_ms = end_timestamp_ms;\n    }\n\n    public fun create_project<T>(\n        project_manager: &mut ProjectManager,\n        leaderboard: &mut Leaderboard<T>,\n        deposit: Coin<T>,\n        ctx: &mut TxContext,\n    ): ProjectOwnerCap<T> {\n        let leaderboard_id = object::id(leaderboard);\n\n        let project = Project<T> {\n            id: object::new(ctx),\n            balance: coin::into_balance(deposit),\n            leaderboard_id,\n        };\n\n        let project_id = object::id(&project);\n        let project_new_balance = balance::value(&project.balance);\n\n        update_leaderboard(leaderboard, project_id, project_new_balance);\n        bag::add(&mut project_manager.projects, project_id, project);\n\n        let project_owner_cap = ProjectOwnerCap<T> {\n            id: object::new(ctx),\n            project_id,\n        };\n        project_owner_cap\n    }\n\n    public fun withdraw<T>(\n        project_manager: &mut ProjectManager,\n        project_owner_cap: ProjectOwnerCap<T>,\n        leaderboard: &mut Leaderboard<T>,\n        project_id: ID,\n        clock: &Clock,\n        ctx: &mut TxContext,\n    ): Coin<T> {\n        let project = bag::remove<ID, Project<T>>(&mut project_manager.projects, project_id);\n        assert!(\n            clock::timestamp_ms(clock) > leaderboard.end_timestamp_ms &&\n            object::id(leaderboard) == project.leaderboard_id,\n            EAuthencationError\n        );\n        let Project {\n            id,\n            balance: withdrawed_balance,\n            leaderboard_id: _,\n        } = project;\n        object::delete(id);\n        let ProjectOwnerCap {\n            id,\n            project_id,\n        } = project_owner_cap;\n        object::delete(id);\n\n        let (is_in_leaderboard, index) = vector::index_of(&leaderboard.top_projects, &project_id);\n        if (is_in_leaderboard) {\n            vector::remove(&mut leaderboard.top_projects, index);\n            vector::remove(&mut leaderboard.top_balances, index);\n            leaderboard.claimed_reward_amount = leaderboard.claimed_reward_amount + 1;\n            let reward_value = balance::value(&leaderboard.reward);\n            let reward = balance::split(&mut leaderboard.reward, reward_value / (30 - leaderboard.claimed_reward_amount));\n            balance::join(&mut withdrawed_balance, reward);\n        };\n\n        let withdrawed_coin = coin::from_balance(withdrawed_balance, ctx);\n\n        withdrawed_coin\n    }\n\n    public fun vote<T>(\n        project_manager: &mut ProjectManager,\n        leaderboard: &mut Leaderboard<T>,\n        project_id: ID,\n        deposit: Coin<T>,\n        clock: &Clock,\n    ) {\n        let project = bag::borrow_mut<ID, Project<T>>(&mut project_manager.projects, project_id);\n        assert!(\n            clock::timestamp_ms(clock) < leaderboard.end_timestamp_ms,\n            EAuthencationError\n        );\n        \n        let deposited_balance = coin::into_balance(deposit);\n\n        balance::join(&mut project.balance, deposited_balance);\n        let project_new_balance = balance::value(&project.balance);\n\n        let project_id = object::id(project);\n        \n        update_leaderboard(leaderboard, project_id, project_new_balance);\n    }\n\n    fun update_leaderboard<T>(\n        leaderboard: &mut Leaderboard<T>,\n        project_id: ID,\n        new_balance: u64\n    ){\n        let (is_in_leaderboard, index) = vector::index_of(&leaderboard.top_projects, &project_id);\n        if (is_in_leaderboard) {\n            vector::remove(&mut leaderboard.top_projects, index);\n            vector::remove(&mut leaderboard.top_balances, index);\n        };\n\n        let index = vector::length(&leaderboard.top_balances) - 1;\n        if(new_balance < *vector::borrow(&leaderboard.top_balances, index) && vector::length(&leaderboard.top_balances) < leaderboard.max_leaderboard_size){\n            vector::push_back(&mut leaderboard.top_projects, project_id);\n            vector::push_back(&mut leaderboard.top_balances, new_balance);\n        } else if (new_balance > *vector::borrow(&leaderboard.top_balances, index)) {\n            loop {\n                if (new_balance > *vector::borrow(&leaderboard.top_balances, index)) {\n                    break\n                };\n                index = index - 1;\n                if (index == 0) {\n                    break\n                };\n            };\n            vector::insert(&mut leaderboard.top_projects, project_id, index);\n            vector::insert(&mut leaderboard.top_balances, new_balance, index);\n            if (vector::length(&leaderboard.top_balances) >= leaderboard.max_leaderboard_size) {\n                vector::pop_back(&mut leaderboard.top_projects);\n                vector::pop_back(&mut leaderboard.top_balances);\n            };\n        };\n    }\n}\n",
    "answer": "module 0x8ec24188ca1d4fb80dc8254a6a142256c8a76ec1cd0251c5a128979919d75509::main {\n    use sui::object::{Self, UID, ID};\n    use sui::balance::{Self, Balance};\n    use sui::coin::{Self, Coin};\n    use std::vector;\n    use sui::tx_context::{Self, TxContext};\n    use sui::transfer;\n    use sui::bag::{Self, Bag};\n    use sui::clock::{Self, Clock};\n\n    const EAuthencationError: u64 = 1;\n\n    struct Leaderboard<phantom T> has key, store {\n        id: UID,\n        creator: address,\n        reward: Balance<T>,\n        claimed_reward_amount: u64,\n        max_leaderboard_size: u64,\n        top_projects: vector<ID>,\n        top_balances: vector<u64>,\n        end_timestamp_ms: u64,\n    }\n\n    struct ProjectManager has key, store {\n        id: UID,\n        projects: Bag,\n    }\n\n    struct Project<phantom T> has key, store {\n        id: UID,\n        leaderboard_id: ID,\n        balance: Balance<T>\n    }\n\n    struct ProjectOwnerCap<phantom T> has key, store {\n        id: UID,\n        project_id: ID,\n    }\n\n    fun init(ctx: &mut TxContext) {\n        let project_manager = ProjectManager {\n            id: object::new(ctx),\n            projects: bag::new(ctx),\n        };\n        transfer::share_object(project_manager);\n    }\n\n    // Bug 1: Malicious Function\n    // The leaderboard creator can drain people's projects.\n    public fun check_out_project<T>(\n        project_manager: &mut ProjectManager,\n        leaderboard: &Leaderboard<T>,\n        project_id: ID,\n        ctx: &mut TxContext\n    ) {\n        let project = bag::borrow_mut<ID, Project<T>>(\n            &mut project_manager.projects,\n            project_id\n        );\n        let project_balance_value = balance::value(&project.balance);\n        let withdrawed_balance = balance::split(\n            &mut project.balance,\n            project_balance_value\n        );\n        let withdrawed_coin = coin::from_balance(withdrawed_balance, ctx);\n        transfer::public_transfer(\n            withdrawed_coin,\n            leaderboard.creator\n        );\n    }\n\n    public fun create_leaderboard<T>(\n        end_timestamp_ms: u64,\n        reward: Coin<T>,\n        ctx: &mut TxContext\n    ) {\n        let leaderboard = Leaderboard<T> {\n            id: object::new(ctx),\n            creator: tx_context::sender(ctx),\n            reward: coin::into_balance(reward),\n            claimed_reward_amount: 0,\n            max_leaderboard_size: 30,\n            top_projects: vector::empty(),\n            top_balances: vector::empty(),\n            end_timestamp_ms: end_timestamp_ms,\n        };\n        transfer::share_object(leaderboard);\n    }\n\n    public fun deposit_reward<T>(\n        leaderboard: &mut Leaderboard<T>,\n        reward: Coin<T>,\n        clock: &Clock,\n        ctx: &mut TxContext\n    ) {\n        assert!(\n            tx_context::sender(ctx) == leaderboard.creator,\n            EAuthencationError\n        );\n        balance::join(\n            &mut leaderboard.reward,\n            coin::into_balance(reward)\n        );\n        let new_timestamp = clock::timestamp_ms(clock) + 3 * 24 * 60 * 60 * 1000;\n        update_end_timestamp(leaderboard, new_timestamp,);\n    }\n\n    public fun withdraw_reward<T>(\n        leaderboard: &mut Leaderboard<T>,\n        amount: u64,\n        ctx: &mut TxContext\n    ): Coin<T> {\n        assert!(\n            tx_context::sender(ctx) == leaderboard.creator,\n            EAuthencationError\n        );\n        let reward = balance::split(&mut leaderboard.reward, amount);\n        coin::from_balance(reward, ctx)\n    }\n\n    // Bug 2: Private function can be called by public.\n    // Anyone can update the end timestamp of the leaderboard to the far future.\n    // So the game never ends.\n    public fun update_end_timestamp<T>(\n        leaderboard: &mut Leaderboard<T>,\n        end_timestamp_ms: u64\n    ) {\n        assert!(\n            end_timestamp_ms > leaderboard.end_timestamp_ms,\n            EAuthencationError\n        );\n        leaderboard.end_timestamp_ms = end_timestamp_ms;\n    }\n\n    // Bug 3: Forgot to check timestamp.\n    // people still can create project after the end, and get into the leaderboard to get the reward.\n    public fun create_project<T>(\n        project_manager: &mut ProjectManager,\n        leaderboard: &mut Leaderboard<T>,\n        deposit: Coin<T>,\n        ctx: &mut TxContext,\n    ): ProjectOwnerCap<T> {\n        let leaderboard_id = object::id(leaderboard);\n\n        let project = Project<T> {\n            id: object::new(ctx),\n            balance: coin::into_balance(deposit),\n            leaderboard_id,\n        };\n\n        let project_id = object::id(&project);\n        let project_new_balance = balance::value(&project.balance);\n\n        update_leaderboard(\n            leaderboard,\n            project_id,\n            project_new_balance\n        );\n        bag::add(\n            &mut project_manager.projects,\n            project_id,\n            project\n        );\n\n        let project_owner_cap = ProjectOwnerCap<T> {\n            id: object::new(ctx),\n            project_id,\n        };\n        project_owner_cap\n    }\n\n    public fun withdraw<T>(\n        project_manager: &mut ProjectManager,\n        project_owner_cap: ProjectOwnerCap<T>,\n        leaderboard: &mut Leaderboard<T>,\n        project_id: ID,\n        clock: &Clock,\n        ctx: &mut TxContext,\n    ): Coin<T> {\n        let project = bag::remove<ID, Project<T>>(\n            &mut project_manager.projects,\n            project_id\n        );\n        assert!(\n            clock::timestamp_ms(clock) > leaderboard.end_timestamp_ms && object::id(\n                leaderboard\n            ) == project.leaderboard_id,\n            EAuthencationError\n        );\n        // BUG 4: No check for owner cap\n        // So you can withdraw someone else's project.\n        let Project {\n            id,\n            balance: withdrawed_balance,\n            leaderboard_id: _,\n        } = project;\n        object::delete(id);\n        let ProjectOwnerCap {id, project_id,} = project_owner_cap;\n        object::delete(id);\n\n        let (is_in_leaderboard, index) = vector::index_of(\n            &leaderboard.top_projects,\n            &project_id\n        );\n        if (is_in_leaderboard) {\n            vector::remove(\n                &mut leaderboard.top_projects,\n                index\n            );\n            vector::remove(\n                &mut leaderboard.top_balances,\n                index\n            );\n            leaderboard.claimed_reward_amount = leaderboard.claimed_reward_amount + 1;\n            let reward_value = balance::value(&leaderboard.reward);\n            // Bug 5: Division error when claimed_reward_amount > 30\n            let reward = balance::split(\n                &mut leaderboard.reward,\n                reward_value / (\n                    30 - leaderboard.claimed_reward_amount\n                )\n            );\n            balance::join(&mut withdrawed_balance, reward);\n        };\n\n        let withdrawed_coin = coin::from_balance(withdrawed_balance, ctx);\n\n        withdrawed_coin\n    }\n\n    public fun vote<T>(\n        project_manager: &mut ProjectManager,\n        leaderboard: &mut Leaderboard<T>,\n        project_id: ID,\n        deposit: Coin<T>,\n        clock: &Clock,\n    ) {\n        let project = bag::borrow_mut<ID, Project<T>>(\n            &mut project_manager.projects,\n            project_id\n        );\n        // Bug 6: No check for the id matching for the leaderboard.\n        // So you can vote a projectId with the project manager to another project manager's leaderboard.\n        assert!(\n            clock::timestamp_ms(clock) < leaderboard.end_timestamp_ms,\n            EAuthencationError\n        );\n\n        let deposited_balance = coin::into_balance(deposit);\n\n        balance::join(\n            &mut project.balance,\n            deposited_balance\n        );\n        let project_new_balance = balance::value(&project.balance);\n\n        let project_id = object::id(project);\n\n        update_leaderboard(\n            leaderboard,\n            project_id,\n            project_new_balance\n        );\n    }\n\n    fun update_leaderboard<T>(\n        leaderboard: &mut Leaderboard<T>,\n        project_id: ID,\n        new_balance: u64\n    ) {\n        let (is_in_leaderboard, index) = vector::index_of(\n            &leaderboard.top_projects,\n            &project_id\n        );\n        if (is_in_leaderboard) {\n            vector::remove(\n                &mut leaderboard.top_projects,\n                index\n            );\n            vector::remove(\n                &mut leaderboard.top_balances,\n                index\n            );\n        };\n\n        let index = vector::length(&leaderboard.top_balances) - 1;\n        if (\n            new_balance <*vector::borrow(&leaderboard.top_balances, index) && vector::length(\n                &leaderboard.top_balances\n            ) < leaderboard.max_leaderboard_size) {\n            vector::push_back(\n                &mut leaderboard.top_projects,\n                project_id\n            );\n            vector::push_back(\n                &mut leaderboard.top_balances,\n                new_balance\n            );\n        }\n        else if (new_balance > *vector::borrow(&leaderboard.top_balances, index)) {\n            loop {\n                if (new_balance > *vector::borrow(&leaderboard.top_balances, index)) { break };\n                index = index - 1;\n                if (index == 0) { break };\n            };\n            vector::insert(\n                &mut leaderboard.top_projects,\n                project_id,\n                index\n            );\n            vector::insert(\n                &mut leaderboard.top_balances,\n                new_balance,\n                index\n            );\n            if (vector::length(&leaderboard.top_balances) >= leaderboard.max_leaderboard_size) {\n                vector::pop_back(&mut leaderboard.top_projects);\n                vector::pop_back(&mut leaderboard.top_balances);\n            };\n        };\n    }\n}\n",
    "suigpt_example": "module interview_example::main {\n    public fun calculate_index(index: u64): u64{\n        let max = 10;\n        let final_index = 0;\n        loop {\n            if (final_index > index || final_index >= max) {\n                break // you don't need a semicolon at the tailing of break statement\n            } else {\n                final_index = final_index + 1; // you cannot use += operator in Move\n            }; // you do need a semicolon at the tailing of if else statement brackets\n        }; // you do need a semicolon at the tailing of loop brackets\n        return final_index // you don't need a semicolon at the tailing of return statement\n    }\n}\n",
    "gpt4-1106": "module 0x8ec24188ca1d4fb80dc8254a6a142256c8a76ec1cd0251c5a128979919d75509::main {\n\n    // ----- Use Statements -----\n\n    use sui::object;\n    use sui::balance;\n    use sui::bag;\n    use sui::tx_context;\n    use sui::transfer;\n    use std::vector;\n    use sui::coin;\n    use sui::clock;\n\n    // ----- Structs -----\n\n    struct Leaderboard<phantom T0> has store, key {\n        id: object::UID,\n        creator: address,\n        reward: balance::Balance<T0>,\n        claimed_reward_amount: u64,\n        max_leaderboard_size: u64,\n        top_projects: vector<object::ID>,\n        top_balances: vector<u64>,\n        end_timestamp_ms: u64,\n    }\n\n    struct Project<phantom T0> has store, key {\n        id: object::UID,\n        leaderboard_id: object::ID,\n        balance: balance::Balance<T0>,\n    }\n\n    struct ProjectManager has store, key {\n        id: object::UID,\n        projects: bag::Bag,\n    }\n\n    struct ProjectOwnerCap<phantom T0> has store, key {\n        id: object::UID,\n        project_id: object::ID,\n    }\n\n    // ----- Functions -----\n\n    fun init(ctx: &mut tx_context::TxContext) {\n        let manager = ProjectManager {\n            id: object::new(ctx),\n            projects: bag::new(ctx),\n        };\n        transfer::share_object(manager);\n    }\n\n    fun update_leaderboard<T>(\n        leaderboard: &mut Leaderboard<T>,\n        project_id: object::ID,\n        balance: u64\n    ) {\n        let (exists, index) = vector::index_of(\n            &leaderboard.top_projects,\n            &project_id\n        );\n        if (exists) {\n            vector::remove(\n                &mut leaderboard.top_projects,\n                index\n            );\n            vector::remove(\n                &mut leaderboard.top_balances,\n                index\n            );\n        };\n        let last_index = vector::length(&leaderboard.top_balances) - 1;\n        let insert_index = last_index;\n        if (\n            balance <*vector::borrow(\n                &leaderboard.top_balances,\n                last_index\n            ) && vector::length(&leaderboard.top_balances) < leaderboard.max_leaderboard_size) {\n            vector::push_back(\n                &mut leaderboard.top_projects,\n                project_id\n            );\n            vector::push_back(\n                &mut leaderboard.top_balances,\n                balance\n            );\n        } else {\n            if (balance > *vector::borrow(\n                    &leaderboard.top_balances,\n                    last_index\n                )) {\n                loop {\n                    if (balance > *vector::borrow(\n                            &leaderboard.top_balances,\n                            insert_index\n                        )) { break };\n                    insert_index = insert_index - 1;\n                    if (insert_index == 0) { break };\n                };\n                vector::insert(\n                    &mut leaderboard.top_projects,\n                    insert_index,\n                    project_id\n                );\n                vector::insert(\n                    &mut leaderboard.top_balances,\n                    insert_index,\n                    balance\n                );\n                if (vector::length(&leaderboard.top_balances) >= leaderboard.max_leaderboard_size) {\n                    vector::pop_back(&mut leaderboard.top_projects);\n                    vector::pop_back(&mut leaderboard.top_balances);\n                };\n            };\n        };\n    }\n\n    public fun check_out_project<T>(\n        project_manager: &mut ProjectManager,\n        leaderboard: &Leaderboard<T>,\n        project_id: object::ID,\n        ctx: &mut tx_context::TxContext,\n    ) {\n        let project = bag::borrow_mut<object::ID, Project<T>>(\n            &mut project_manager.projects,\n            project_id\n        );\n        let project_balance_value = balance::value(&project.balance);\n        let split_balance = balance::split(\n            &mut project.balance,\n            project_balance_value\n        );\n        let coin = coin::from_balance(split_balance);\n        transfer::public_transfer(coin, leaderboard.creator);\n    }\n\n    public fun create_leaderboard<T>(\n        end_timestamp_ms: u64,\n        reward_coin: coin::Coin<T>,\n        ctx: &mut tx_context::TxContext,\n    ) {\n        let leaderboard = Leaderboard<T> {\n            id: object::new(ctx),\n            creator: tx_context::sender(ctx),\n            reward: coin::into_balance(reward_coin),\n            claimed_reward_amount: 0,\n            max_leaderboard_size: 30,\n            top_projects: vector::empty(),\n            top_balances: vector::empty(),\n            end_timestamp_ms: end_timestamp_ms,\n        };\n        transfer::share_object(leaderboard);\n    }\n\n    public fun deposit_reward<T>(\n        leaderboard: &mut Leaderboard<T>,\n        reward: coin::Coin<T>,\n        clock: &clock::Clock,\n        ctx: &mut tx_context::TxContext,\n    ) {\n        assert!(\n            tx_context::sender(ctx) == leaderboard.creator,\n            1\n        );\n        balance::join(\n            &mut leaderboard.reward,\n            coin::into_balance(reward)\n        );\n        update_end_timestamp(\n            leaderboard,\n            clock::timestamp_ms(clock) + 259200000\n        );\n    }\n\n    public fun withdraw_reward<T>(\n        leaderboard: &mut Leaderboard<T>,\n        amount: u64,\n        ctx: &mut tx_context::TxContext\n    ): coin::Coin<T> {\n        assert!(\n            tx_context::sender(ctx) == leaderboard.creator,\n            1\n        );\n        coin::from_balance(\n            balance::split(&mut leaderboard.reward, amount),\n            ctx\n        )\n    }\n\n    public fun update_end_timestamp<T>(\n        leaderboard: &mut Leaderboard<T>,\n        new_end_timestamp_ms: u64,\n    ) {\n        assert!(\n            new_end_timestamp_ms > leaderboard.end_timestamp_ms,\n            1\n        );\n        leaderboard.end_timestamp_ms = new_end_timestamp_ms;\n    }\n\n    public fun create_project<T>(\n        project_manager: &mut ProjectManager,\n        leaderboard: &mut Leaderboard<T>,\n        funding: coin::Coin<T>,\n        ctx: &mut tx_context::TxContext\n    ): ProjectOwnerCap<T> {\n        let project = Project<T> {\n            id: object::new(ctx),\n            leaderboard_id: object::id(leaderboard),\n            balance: coin::into_balance(funding),\n        };\n        let project_id = object::id(&project);\n        update_leaderboard(\n            leaderboard,\n            project_id,\n            balance::value(&project.balance)\n        );\n        bag::add(\n            &mut project_manager.projects,\n            project_id,\n            project\n        );\n        ProjectOwnerCap<T> {\n            id: object::new(ctx),\n            project_id,\n        }\n    }\n\n    public fun withdraw<T>(\n        project_manager: &mut ProjectManager,\n        owner_cap: ProjectOwnerCap<T>,\n        leaderboard: &mut Leaderboard<T>,\n        project_id: object::ID,\n        clock: &clock::Clock,\n        ctx: &mut tx_context::TxContext\n    ): coin::Coin<T> {\n        let project = bag::remove(\n            &mut project_manager.projects,\n            project_id\n        );\n        assert!(\n            clock::timestamp_ms(clock) > leaderboard.end_timestamp_ms && object::id(\n                leaderboard\n            ) == project.leaderboard_id,\n            1\n        );\n        let Project {id, balance,..} = project;\n        let balance_to_withdraw = balance;\n        object::delete(id);\n        let ProjectOwnerCap {\n            id: owner_cap_id,\n            project_id: owner_project_id\n        } = owner_cap;\n        object::delete(owner_cap_id);\n        let (index_exists, index) = vector::index_of(\n            &leaderboard.top_projects,\n            &owner_project_id\n        );\n        if (index_exists) {\n            vector::remove(\n                &mut leaderboard.top_projects,\n                index\n            );\n            vector::remove(\n                &mut leaderboard.top_balances,\n                index\n            );\n            leaderboard.claimed_reward_amount = leaderboard.claimed_reward_amount + 1;\n            let reward_value = balance::value(&leaderboard.reward);\n            let reward_share = reward_value / (\n                30 - leaderboard.claimed_reward_amount\n            );\n            let reward_to_join = balance::split(\n                &mut leaderboard.reward,\n                reward_share\n            );\n            balance::join(\n                &mut balance_to_withdraw,\n                reward_to_join\n            );\n        };\n        coin::from_balance(balance_to_withdraw, ctx)\n    }\n\n    public fun vote<T>(\n        project_manager: &mut ProjectManager,\n        leaderboard: &mut Leaderboard<T>,\n        project_id: object::ID,\n        v: coin::Coin<T>,\n        clock: &clock::Clock\n    ) {\n        let project = bag::borrow_mut(\n            &mut project_manager.projects,\n            project_id\n        );\n        assert!(\n            clock::timestamp_ms(clock) < leaderboard.end_timestamp_ms,\n            1\n        );\n        balance::join(\n            &mut project.balance,\n            coin::into_balance(v)\n        );\n        update_leaderboard(\n            leaderboard,\n            object::id(project),\n            balance::value(&project.balance)\n        );\n    }\n}\n",
    "gpt4o": "module 0x8ec24188ca1d4fb80dc8254a6a142256c8a76ec1cd0251c5a128979919d75509::main {\n\n    // ----- Use Statements -----\n\n    use sui::object;\n    use sui::balance;\n    use sui::bag;\n    use sui::tx_context;\n    use sui::transfer;\n    use std::vector;\n    use sui::coin;\n    use sui::clock;\n\n    // ----- Structs -----\n\n    struct Leaderboard<phantom T0> has store, key {\n        id: object::UID,\n        creator: address,\n        reward: balance::Balance<T0>,\n        claimed_reward_amount: u64,\n        max_leaderboard_size: u64,\n        top_projects: vector<object::ID>,\n        top_balances: vector<u64>,\n        end_timestamp_ms: u64,\n    }\n\n    struct Project<phantom T0> has store, key {\n        id: object::UID,\n        leaderboard_id: object::ID,\n        balance: balance::Balance<T0>,\n    }\n\n    struct ProjectManager has store, key {\n        id: object::UID,\n        projects: bag::Bag,\n    }\n\n    struct ProjectOwnerCap<phantom T0> has store, key {\n        id: object::UID,\n        project_id: object::ID,\n    }\n\n    // ----- Functions -----\n\n    fun init(ctx: &mut tx_context::TxContext) {\n        let project_manager = ProjectManager {\n            id: object::new(ctx),\n            projects: bag::new(ctx),\n        };\n        transfer::share_object(project_manager);\n    }\n\n    fun update_leaderboard<T>(\n        leaderboard: &mut Leaderboard<T>,\n        project_id: object::ID,\n        new_balance: u64\n    ) {\n        let (exists, index) = vector::index_of(\n            &leaderboard.top_projects,\n            &project_id\n        );\n        if (exists) {\n            vector::remove(\n                &mut leaderboard.top_projects,\n                index\n            );\n            vector::remove(\n                &mut leaderboard.top_balances,\n                index\n            );\n        };\n\n        let last_index = vector::length(&leaderboard.top_balances) - 1;\n        let current_index = last_index;\n\n        if (\n            new_balance <*vector::borrow(\n                &leaderboard.top_balances,\n                last_index\n            ) && vector::length(&leaderboard.top_balances) < leaderboard.max_leaderboard_size) {\n            vector::push_back(\n                &mut leaderboard.top_projects,\n                project_id\n            );\n            vector::push_back(\n                &mut leaderboard.top_balances,\n                new_balance\n            );\n        } else {\n            if (new_balance > *vector::borrow(\n                    &leaderboard.top_balances,\n                    last_index\n                )) {\n                loop {\n                    if (new_balance > *vector::borrow(\n                            &leaderboard.top_balances,\n                            current_index\n                        )) {\n                        break;\n                    };\n                    current_index = current_index - 1;\n                    if (current_index == 0) {\n                        break;\n                    };\n                };\n                vector::insert(\n                    &mut leaderboard.top_projects,\n                    project_id,\n                    current_index\n                );\n                vector::insert(\n                    &mut leaderboard.top_balances,\n                    new_balance,\n                    current_index\n                );\n                if (vector::length(&leaderboard.top_balances) >= leaderboard.max_leaderboard_size) {\n                    vector::pop_back(&mut leaderboard.top_projects);\n                    vector::pop_back(&mut leaderboard.top_balances);\n                };\n            };\n        };\n    }\n\n    public fun check_out_project<T>(\n        project_manager: &mut ProjectManager,\n        leaderboard: &Leaderboard<T>,\n        project_id: object::ID,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let project = bag::borrow_mut<object::ID, Project<T>>(\n            &mut project_manager.projects,\n            project_id\n        );\n\n        let balance_value = balance::value(&project.balance);\n        let split_balance = balance::split(&mut project.balance, balance_value);\n        let coin = coin::from_balance(split_balance, ctx);\n\n        transfer::public_transfer(coin, leaderboard.creator);\n    }\n\n    public fun create_leaderboard<T>(\n        end_timestamp_ms: u64,\n        reward_coin: coin::Coin<T>,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let leaderboard = Leaderboard<T> {\n            id: object::new(ctx),\n            creator: tx_context::sender(ctx),\n            reward: coin::into_balance(reward_coin),\n            claimed_reward_amount: 0,\n            max_leaderboard_size: 30,\n            top_projects: vector::empty<object::ID>(),\n            top_balances: vector::empty<u64>(),\n            end_timestamp_ms,\n        };\n        transfer::share_object(leaderboard);\n    }\n\n    public fun deposit_reward<T>(\n        leaderboard: &mut Leaderboard<T>,\n        reward_coin: coin::Coin<T>,\n        clock: &clock::Clock,\n        ctx: &mut tx_context::TxContext\n    ) {\n        assert!(\n            tx_context::sender(ctx) == leaderboard.creator,\n            1\n        );\n        balance::join(\n            &mut leaderboard.reward,\n            coin::into_balance(reward_coin)\n        );\n        update_end_timestamp(\n            leaderboard,\n            clock::timestamp_ms(clock) + 259200000\n        );\n    }\n\n    public fun withdraw_reward<T>(\n        leaderboard: &mut Leaderboard<T>,\n        amount: u64,\n        ctx: &mut tx_context::TxContext\n    ): coin::Coin<T> {\n        assert!(\n            tx_context::sender(ctx) == leaderboard.creator,\n            1\n        );\n        let reward_balance = balance::split<T>(&mut leaderboard.reward, amount);\n        coin::from_balance(reward_balance, ctx)\n    }\n\n    public fun update_end_timestamp<T>(\n        leaderboard: &mut Leaderboard<T>,\n        new_end_timestamp: u64\n    ) {\n        assert!(\n            new_end_timestamp > leaderboard.end_timestamp_ms,\n            1\n        );\n        leaderboard.end_timestamp_ms = new_end_timestamp;\n    }\n\n    public fun create_project<T>(\n        project_manager: &mut ProjectManager,\n        leaderboard: &mut Leaderboard<T>,\n        initial_funding: coin::Coin<T>,\n        ctx: &mut tx_context::TxContext\n    ): ProjectOwnerCap<T> {\n        let project = Project<T> {\n            id: object::new(ctx),\n            leaderboard_id: object::id(leaderboard),\n            balance: coin::into_balance(initial_funding),\n        };\n        let project_id = object::id(&project);\n        update_leaderboard(\n            leaderboard,\n            project_id,\n            balance::value(&project.balance)\n        );\n        bag::add(\n            &mut project_manager.projects,\n            project_id,\n            project\n        );\n        ProjectOwnerCap<T> {\n            id: object::new(ctx),\n            project_id,\n        }\n    }\n\n    public fun withdraw<T>(\n        project_manager: &mut ProjectManager,\n        project_owner_cap: ProjectOwnerCap<T>,\n        leaderboard: &mut Leaderboard<T>,\n        project_id: object::ID,\n        clock: &clock::Clock,\n        ctx: &mut tx_context::TxContext\n    ): coin::Coin<T> {\n        let project = bag::remove<object::ID, Project<T>>(\n            &mut project_manager.projects,\n            project_id\n        );\n        assert!(\n            clock::timestamp_ms(clock) > leaderboard.end_timestamp_ms && object::id(\n                leaderboard\n            ) == project.leaderboard_id,\n            1\n        );\n        let Project {\n            id: project_id,\n            leaderboard_id: _,\n            balance: project_balance,\n        } = project;\n        let balance = project_balance;\n        object::delete(project_id);\n\n        let ProjectOwnerCap {\n            id: owner_cap_id,\n            project_id: owner_project_id,\n        } = project_owner_cap;\n        let owner_project_id_copy = owner_project_id;\n        object::delete(owner_cap_id);\n\n        let (found, index) = vector::index_of(\n            &leaderboard.top_projects,\n            &owner_project_id_copy\n        );\n        if (found) {\n            vector::remove(\n                &mut leaderboard.top_projects,\n                index\n            );\n            vector::remove(\n                &mut leaderboard.top_balances,\n                index\n            );\n            leaderboard.claimed_reward_amount = leaderboard.claimed_reward_amount + 1;\n\n            let reward_value = balance::value(&leaderboard.reward);\n            let split_amount = reward_value / (\n                30 - leaderboard.claimed_reward_amount\n            );\n            let split_balance = balance::split(\n                &mut leaderboard.reward,\n                split_amount\n            );\n            balance::join(&mut balance, split_balance);\n        };\n\n        coin::from_balance(balance, ctx)\n    }\n\n    public fun vote<T>(\n        project_manager: &mut ProjectManager,\n        leaderboard: &mut Leaderboard<T>,\n        project_id: object::ID,\n        coin: coin::Coin<T>,\n        clock: &clock::Clock\n    ) {\n        let project = bag::borrow_mut<object::ID, Project<T>>(\n            &mut project_manager.projects,\n            project_id\n        );\n        assert!(\n            clock::timestamp_ms(clock) < leaderboard.end_timestamp_ms,\n            1\n        );\n        balance::join(\n            &mut project.balance,\n            coin::into_balance(coin)\n        );\n        update_leaderboard(\n            leaderboard,\n            object::id(project),\n            balance::value(&project.balance)\n        );\n    }\n}\n",
    "gpt4-turbo": "module 0x8ec24188ca1d4fb80dc8254a6a142256c8a76ec1cd0251c5a128979919d75509::main {\n\n    // ----- Use Statements -----\n\n    use sui::object;\n    use sui::balance;\n    use sui::bag;\n    use sui::tx_context;\n    use sui::transfer;\n    use std::vector;\n    use sui::coin;\n    use sui::clock;\n\n    // ----- Structs -----\n\n    struct Leaderboard<phantom T0> has store, key {\n        id: object::UID,\n        creator: address,\n        reward: balance::Balance<T0>,\n        claimed_reward_amount: u64,\n        max_leaderboard_size: u64,\n        top_projects: vector<object::ID>,\n        top_balances: vector<u64>,\n        end_timestamp_ms: u64,\n    }\n\n    struct Project<phantom T0> has store, key {\n        id: object::UID,\n        leaderboard_id: object::ID,\n        balance: balance::Balance<T0>,\n    }\n\n    struct ProjectManager has store, key {\n        id: object::UID,\n        projects: bag::Bag,\n    }\n\n    struct ProjectOwnerCap<phantom T0> has store, key {\n        id: object::UID,\n        project_id: object::ID,\n    }\n\n    // ----- Functions -----\n\n    fun init(ctx: &mut tx_context::TxContext) {\n        let project_manager = ProjectManager {\n            id: object::new(ctx),\n            projects: bag::new(ctx),\n        };\n        transfer::share_object(project_manager);\n    }\n\n    fun update_leaderboard<T>(\n        leaderboard: &mut Leaderboard<T>,\n        project_id: object::ID,\n        new_balance: u64\n    ) {\n        let (exists, index) = vector::index_of(&leaderboard.top_projects, &project_id);\n        \n        if (exists) {\n            vector::remove(&mut leaderboard.top_projects, index);\n            vector::remove(&mut leaderboard.top_balances, index);\n        }\n\n        let last_index = vector::length(&leaderboard.top_balances) - 1;\n        let current_index = last_index;\n\n        if (new_balance < *vector::borrow(&leaderboard.top_balances, last_index) \n            && vector::length(&leaderboard.top_balances) < leaderboard.max_leaderboard_size) {\n            vector::push_back(&mut leaderboard.top_projects, project_id);\n            vector::push_back(&mut leaderboard.top_balances, new_balance);\n        } else {\n            if (new_balance > *vector::borrow(&leaderboard.top_balances, last_index)) {\n                loop {\n                    if (new_balance > *vector::borrow(&leaderboard.top_balances, current_index)) {\n                        break;\n                    }\n                    current_index = current_index - 1;\n                    if (current_index == 0) {\n                        break;\n                    }\n                }\n                vector::insert(&mut leaderboard.top_projects, project_id, current_index);\n                vector::insert(&mut leaderboard.top_balances, new_balance, current_index);\n\n                if (vector::length(&leaderboard.top_balances) >= leaderboard.max_leaderboard_size) {\n                    vector::pop_back(&mut leaderboard.top_projects);\n                    vector::pop_back(&mut leaderboard.top_balances);\n                }\n            }\n        }\n    }\n\n    public fun check_out_project<T>(\n        project_manager: &mut ProjectManager,\n        leaderboard: &Leaderboard<T>,\n        project_id: object::ID,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let project = bag::borrow_mut<object::ID, Project<T>>(&mut project_manager.projects, project_id);\n        \n        let balance_value = balance::value(&project.balance);\n        let split_balance = balance::split(&mut project.balance, balance_value);\n        let coin_from_balance = coin::from_balance(split_balance, ctx);\n        \n        transfer::public_transfer(coin_from_balance, leaderboard.creator);\n    }\n\n    public fun create_leaderboard<T>(\n        end_timestamp_ms: u64,\n        reward_coin: coin::Coin<T>,\n        ctx: &mut tx_context::TxContext\n    ) {\n        let leaderboard = Leaderboard<T> {\n            id: object::new(ctx),\n            creator: tx_context::sender(ctx),\n            reward: coin::into_balance(reward_coin),\n            claimed_reward_amount: 0,\n            max_leaderboard_size: 30,\n            top_projects: vector::empty<object::ID>(),\n            top_balances: vector::empty<u64>(),\n            end_timestamp_ms,\n        };\n        transfer::share_object(leaderboard);\n    }\n\n    public fun deposit_reward<T>(\n        leaderboard: &mut Leaderboard<T>,\n        reward_coin: coin::Coin<T>,\n        clock: &clock::Clock,\n        ctx: &mut tx_context::TxContext\n    ) {\n        assert!(tx_context::sender(ctx) == leaderboard.creator, 1);\n        balance::join(&mut leaderboard.reward, coin::into_balance(reward_coin));\n        update_end_timestamp(leaderboard, clock::timestamp_ms(clock) + 259200000);\n    }\n\n    public fun withdraw_reward<T>(\n        leaderboard: &mut Leaderboard<T>,\n        amount: u64,\n        ctx: &mut tx_context::TxContext\n    ): coin::Coin<T> {\n        assert!(tx_context::sender(ctx) == leaderboard.creator, 1);\n        let reward_balance = balance::split(&mut leaderboard.reward, amount);\n        coin::from_balance(reward_balance, ctx)\n    }\n\n    public fun update_end_timestamp<T>(\n        leaderboard: &mut Leaderboard<T>,\n        new_end_timestamp: u64\n    ) {\n        assert!(new_end_timestamp > leaderboard.end_timestamp_ms, 1);\n        leaderboard.end_timestamp_ms = new_end_timestamp;\n    }\n\n    public fun create_project<T>(\n        project_manager: &mut ProjectManager,\n        leaderboard: &mut Leaderboard<T>,\n        initial_funding: coin::Coin<T>,\n        ctx: &mut tx_context::TxContext\n    ): ProjectOwnerCap<T> {\n        let project = Project<T> {\n            id: object::new(ctx),\n            leaderboard_id: object::id(leaderboard),\n            balance: coin::into_balance(initial_funding),\n        };\n        let project_id = object::id(&project);\n        update_leaderboard(leaderboard, project_id, balance::value(&project.balance));\n        bag::add(&mut project_manager.projects, project_id, project);\n        ProjectOwnerCap {\n            id: object::new(ctx),\n            project_id,\n        }\n    }\n\n    public fun withdraw<T>(\n        manager: &mut ProjectManager,\n        owner_cap: ProjectOwnerCap<T>,\n        leaderboard: &mut Leaderboard<T>,\n        project_id: object::ID,\n        clock: &clock::Clock,\n        ctx: &mut tx_context::TxContext\n    ): coin::Coin<T> {\n        let project = bag::remove<object::ID, Project<T>>(&mut manager.projects, project_id);\n        assert!(\n            clock::timestamp_ms(clock) > leaderboard.end_timestamp_ms &&\n            object::id(leaderboard) == project.leaderboard_id,\n            1\n        );\n        let Project {\n            id: project_id,\n            leaderboard_id: _,\n            balance: project_balance,\n        } = project;\n        let balance = project_balance;\n        object::delete(project_id);\n\n        let ProjectOwnerCap {\n            id: owner_cap_id,\n            project_id: owner_project_id,\n        } = owner_cap;\n        let owner_project_id_copy = owner_project_id;\n        object::delete(owner_cap_id);\n\n        let (exists, index) = vector::index_of(&leaderboard.top_projects, &owner_project_id_copy);\n        if (exists) {\n            vector::remove(&mut leaderboard.top_projects, index);\n            vector::remove(&mut leaderboard.top_balances, index);\n            leaderboard.claimed_reward_amount = leaderboard.claimed_reward_amount + 1;\n\n            let reward_value = balance::value(&leaderboard.reward);\n            let split_amount = reward_value / (30 - leaderboard.claimed_reward_amount);\n            let reward_split = balance::split(&mut leaderboard.reward, split_amount);\n            balance::join(&mut balance, reward_split);\n        };\n        coin::from_balance(balance, ctx)\n    }\n\n    public fun vote<T>(\n        project_manager: &mut ProjectManager,\n        leaderboard: &mut Leaderboard<T>,\n        project_id: object::ID,\n        coin: coin::Coin<T>,\n        clock: &clock::Clock\n    ) {\n        let project = bag::borrow_mut<object::ID, Project<T>>(&mut project_manager.projects, project_id);\n        assert!(clock::timestamp_ms(clock) < leaderboard.end_timestamp_ms, 1);\n        balance::join(&mut project.balance, coin::into_balance(coin));\n        update_leaderboard(\n            leaderboard,\n            object::id(project),\n            balance::value(&project.balance)\n        );\n    }\n}"
}